import os
import json
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ApplicationBuilder, CommandHandler, CallbackQueryHandler, ContextTypes

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

TOKEN = '7943917934:AAFlfQqO-7Rm1giXntcnoBUsYi9QgSVAWTI'

# –§—É–Ω–∫—Ü–∏—è –∑–∞–≥—Ä—É–∑–∫–∏ –≤—Å–µ—Ö –±–∏–ª–µ—Ç–æ–≤
def load_tickets():
    # –ü—É—Ç—å –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ç–µ–∫—É—â–µ–≥–æ —Ñ–∞–π–ª–∞
    tickets_dir = os.path.join(os.path.dirname(__file__), 'tickets')



    tickets = {}
    for file in os.listdir(tickets_dir):
        ticket_name, ticket_extension = os.path.splitext(file)
        if ticket_extension == '.json':
            ticket_path = os.path.join(tickets_dir, file)
            with open(ticket_path) as f:
                ticket = json.load(f)
            tickets[ticket_name] = ticket
    return tickets

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –±–∏–ª–µ—Ç–∞
def load_ticket(ticket_id):
    tickets = load_tickets()  # –ó–∞–≥—Ä—É–∂–∞–µ–º –≤—Å–µ –±–∏–ª–µ—Ç—ã
    return tickets.get(ticket_id)  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –±–∏–ª–µ—Ç –ø–æ –µ–≥–æ ID

# –°—Ç–∞—Ä—Ç–æ–≤–∞—è –∫–æ–º–∞–Ω–¥–∞ /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.info(f"User {update.message.chat.id} started the bot.")
    keyboard = [
        [InlineKeyboardButton("üìÑ –ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π —Ç–µ—Å—Ç", callback_data='start_test')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("–ë–∏–ª–µ—Ç—ã –ü–î–î 2023, 2024 –≥.\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=reply_markup)

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –∫–Ω–æ–ø–∫–∏ "–ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π —Ç–µ—Å—Ç"
async def start_test(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    logger.info(f"User {query.message.chat.id} clicked '–ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π —Ç–µ—Å—Ç'.")
    await query.answer()

    keyboard = [[InlineKeyboardButton(f"‚Ññ {i}", callback_data=f"ticket_{i}") for i in range(1, 6)],  
                [InlineKeyboardButton(f"‚Ññ {i}", callback_data=f"ticket_{i}") for i in range(6, 11)]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–º–µ—Ä –±–∏–ª–µ—Ç–∞:", reply_markup=reply_markup)

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ –±–∏–ª–µ—Ç–∞
async def select_ticket(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    logger.info(f"User {query.message.chat.id} selected ticket {query.data}.")
    await query.answer()

    ticket_id = query.data  # –ü–æ–ª—É—á–∞–µ–º ID –±–∏–ª–µ—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "ticket_1")
    ticket_data = load_ticket(ticket_id)  # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –±–∏–ª–µ—Ç–∞

    if not ticket_data:
        logger.error(f"Ticket {ticket_id} not found")
        await query.message.reply_text(f"–ë–∏–ª–µ—Ç {ticket_id} –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return

    await send_question(update, context, ticket_id, 0)  # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–µ—Ä–≤—ã–π –≤–æ–ø—Ä–æ—Å –±–∏–ª–µ—Ç–∞

# –§—É–Ω–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤–æ–ø—Ä–æ—Å–∞ —Å —Ñ–æ—Ç–æ –∏–ª–∏ –±–µ–∑
async def send_question(update: Update, context: ContextTypes.DEFAULT_TYPE, ticket_id, question_index):
    question_data = load_ticket(ticket_id)[question_index]

    question_text = f"–ë–∏–ª–µ—Ç ‚Ññ {ticket_id.split('_')[1]}, –≤–æ–ø—Ä–æ—Å {question_index + 1} –∏–∑ 20\n\n"
    question_text += f"{question_data['question']}\n\n"

    for i, option in enumerate(question_data['options']):
        question_text += f"{i + 1}. {option}\n"

    if 'image_path' in question_data:
        photo_path = question_data['image_path']
        await update.callback_query.message.reply_photo(photo=open(photo_path, 'rb'))

    options = [
        [InlineKeyboardButton(f"{i + 1}. {option}", callback_data=f"{ticket_id}_q{question_index}_{i}")]
        for i, option in enumerate(question_data['options'])
    ]
    reply_markup = InlineKeyboardMarkup(options)

    await update.callback_query.message.reply_text(question_text, reply_markup=reply_markup)

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–≤–µ—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
async def handle_answer(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    callback_data = query.data
    logger.info(f"User {query.message.chat.id} answered question: {callback_data}")

    await query.answer()

    try:
        data_parts = callback_data.split('_')
        logger.info(f"Data parts after split: {data_parts}")

        if len(data_parts) != 4:
            raise ValueError(f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ callback_data: {len(data_parts)}")

        ticket_id = f"ticket_{data_parts[1]}"  
        question_id = int(data_parts[2][1:])   
        selected_option = int(data_parts[3])   

        logger.info(f"Ticket ID: {ticket_id}, Question ID: {question_id}, Selected Option: {selected_option}")

        question_data = load_ticket(ticket_id)[question_id]
        correct_option = question_data['correct_option']

        options = []
        for i, option in enumerate(question_data['options']):
            if i == correct_option:
                options.append([InlineKeyboardButton(f"‚úÖ {i + 1}. {option}", callback_data=f"{ticket_id}_q{question_id}_{i}")])
            elif i == selected_option:
                options.append([InlineKeyboardButton(f"‚ùå {i + 1}. {option}", callback_data=f"{ticket_id}_q{question_id}_{i}")])
            else:
                options.append([InlineKeyboardButton(f"{i + 1}. {option}", callback_data=f"{ticket_id}_q{question_id}_{i}")])

        reply_markup = InlineKeyboardMarkup(options)
        await query.message.edit_reply_markup(reply_markup=reply_markup)

        if selected_option != correct_option:
            await query.message.reply_text(f"–ü–æ–¥—Å–∫–∞–∑–∫–∞üí° {question_data['hint']}")

        next_question = question_id + 1
        if next_question < len(load_ticket(ticket_id)):
            await send_question(update, context, ticket_id, next_question)
        else:
            await query.message.reply_text("–¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à—ë–Ω!")

    except ValueError as e:
        logger.error(f"Error processing callback data: {e}")
        await query.message.reply_text(f"–û—à–∏–±–∫–∞ –≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ –¥–∞–Ω–Ω—ã—Ö: {e}")

# –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞
def main():
    app = ApplicationBuilder().token(TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CallbackQueryHandler(start_test, pattern='start_test'))
    app.add_handler(CallbackQueryHandler(select_ticket, pattern=r'^ticket_\d+$'))
    app.add_handler(CallbackQueryHandler(handle_answer, pattern=r'^ticket_\d+_q\d+_\d+$'))

    app.run_polling()

if __name__ == '__main__':
    main()
